package main;

import java.io.Console;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;

import ast.AST;
import compiler.Compiler;
import parsing.Lexer;
import parsing.Parser;
import vm.VM;

//this code is based on the books "Language Implementation Patterns" by Terrence Parr and "Crafting Interpreters" by Robert Nystrom


//a class for the actual interpreter-app
//runs source code, can be configured
public class InterpreterApp {
	public String sourcePath; //the path of the source code
	public boolean benchmarking = false; //should the interpreter print out the compiliation and execution-time
	public boolean traceExecution = false; //should the virtual machine trace the execution?
	public boolean printBytecode = false; //should the generated bytecode be printed
	public boolean runProgram = true; //should the bytecode be executed?
	public int mode = 0; //what the interpreter should do with the source-code: 0 --> execute, 1 --> print byte-code
	
	public InterpreterApp(String[] args) {
		parseArgs(args);
	}
	
	//parses the arguments that are given to the program
	public void parseArgs(String[] args) {
		int p = 0;
		while(p < args.length) {
			String arg = args[p];
			
			if(arg.charAt(0) == '-') {
				//option
				switch(arg.substring(1)) {
				case "b": case "benchmarking":
					//benchmarking
					int x = Integer.parseInt(args[++p]);
					benchmarking = x > 0;
					break;
				case "t": case "traceExecution":
					//trace execution
					x = Integer.parseInt(args[++p]);
					traceExecution = x > 0;
					break;
				case "pb": case "printBytecode":
					//print bytecode
					x = Integer.parseInt(args[++p]);
					printBytecode = x > 0;
					break;
				case "r": case "runProgram":
					//run program
					x = Integer.parseInt(args[++p]);
					runProgram = x > 0;
					break;
				}
			}else {
				//source-path
				sourcePath = arg;
			}
			
			++p;
		}
	}
	
	//compiles and executes the program
	//lexer -> parser -> compiler -> virtual machine
	public void exec() throws IOException {
		String inputText = Files.readString(Path.of(sourcePath));
		
		long compilationStart = System.currentTimeMillis();

		Lexer lexer = new Lexer(inputText);
		
		Parser parser = new Parser(lexer);
		
		//parse source-code with tokens from the lexer
		AST tree = parser.parse();
		
		//compile the ast to bytecode
		Compiler compiler = new Compiler();
		compiler.compile(tree);
		
		if(printBytecode) {
			//print the generated bytecode
			compiler.code.printCode();
			System.out.println();
		}
		
		if(benchmarking) {
			//calculate and print the compiliation time
			long compilationTime = System.currentTimeMillis() - compilationStart;
			double compilationSeconds = compilationTime / 1000.0;
			System.out.println("[*] compilation finished in " + compilationSeconds + " seconds");
		}
		
		
		VM vm = new VM(compiler.code);
		vm.traceExecution = traceExecution;
		
		if(benchmarking) {
			System.out.println("[*] starting program...");
			System.out.println();
		}
		
		if(runProgram) {
			long execStart = System.currentTimeMillis();
			
			//execute the bytecode
			vm.cpu();
			
			if(benchmarking) {
				//calculate and print the execution time
				long execTime = System.currentTimeMillis() - execStart;
				double execTimeSeconds = execTime / 1000.0;
				
				System.out.println();
				System.out.println("[*] execution finished in " + execTimeSeconds + " seconds");
			}
		}
		
	}
	
	public static void main(String[] args) throws IOException {
		if(args.length > 0) {
			InterpreterApp app = new InterpreterApp(args);
			try {
				app.exec();
			}catch(RuntimeException ex) {
				//print the error-type (parsing-error, compiler-error, etc.)
				System.err.println(ex.getClass().getSimpleName());
			} catch (IOException e) {
				System.err.println("Could not open the file at " + app.sourcePath);
			}
		}
	}
}
