package vm;

import java.util.Scanner;

import compiler.CompilerError;

//the virtual machine which executes the code generated by a compiler
public class VM {
	private static final int MAX_STACK_SIZE = 128; //the size of the stack array --> the stack can't grow any bigger
	private Code code; //the bytecode that was generated by the compiler
	private Value[] stack = new Value[MAX_STACK_SIZE]; //the stack: constant values are saved in this array. Behaves like a stack
	private int sp = -1; //the stack-pointer: the index of the current top of the stack
	private int ip = 0; //the instruction-pointer: marks where the virtual machine is currently in the code-data
	private Value[] globals; //an array which stores the value of the different variables --> the globals are indexed by a byte-id
	public boolean traceExecution = false; //should the current instruction and the stack be printed every execution-cycle for debugging?
	private Scanner consoleInput = new Scanner(System.in); //is needed to read input in the console in Java
	
	public VM(Code code) {
		this.code = code;
		this.globals = new Value[code.numGlobals]; //inits the globals array with the number of globals that will be declared while the program is running
	}

	//pushes a value on top of the stack
	private void push(Value value) {
		if(sp >= MAX_STACK_SIZE - 1) {
			throw error("stack overflow; max-stack-size = " + MAX_STACK_SIZE + "!");
		}
		stack[++sp] = value;
	}
	
	//returns the top value of the stack and deletes it
	private Value pop() {
		return stack[sp--];
	}
	
	//the core of the virtual-machine which executes the code
	//keeps it running and acts like a processor
	public void cpu() {
		while(ip < code.data.size()) {
			byte instr = getCode(ip);
			
			//should the current instruction be print? --> debugging
			if(traceExecution) {
				code.printOp(instr, ip);
			}
			
			//execute the current instruction
			exec(instr);
			
			//should the stack be print? --> debugging
			if(traceExecution) {
				printStack();
				System.out.println();
			}
			
			++ip;
		}
	}
	
	//prints the stack --> for debugging
	private void printStack() {
		System.out.print("[");
		for(int i = 0; i <= sp; ++i) {
			if(i > 0) {
				System.out.print(", ");
			}
			System.out.print(stack[i].dataToString());
		}
		System.out.println("]");
	}
	
	//executes the current instruction
	private void exec(byte instr) {
		switch(instr) {
		case Op.CONSTANT:
			//gets the constant and pushes it on the stack
			Value val = readConstant();
			push(val);
			break;
		case Op.TRUE:
			//pushes true as a boolean on the stack
			push(new Value(true));
			break;
		case Op.FALSE:
			//pushes false as a boolean on the stack
			push(new Value(false));
			break;
		case Op.NOT:
			//inverts the current boolean value on top of the stack (true -> false, false -> true)
			val = pop();
			if(!val.isBool()) {
				throw error("cannot use the not operator on " + val.type);
			}else {
				push(new Value(!val.asBool()));
			}
			
			break;
		case Op.OUT:
			//pops the top value off the stack and prints it
			val = pop();
			System.out.println(val.dataToString());
			break;
		case Op.EQUALS, Op.BANG_EQUALS:
			//do the two top values on the stack equal? Pushes the result of the comparison on the stack 
			//(if the instruction is Op.BANG_EQUALS the result is first inverted)
			Value b = pop();
			Value a = pop();
			
			boolean resultVal = valuesEqual(a, b);
			
			if(instr == Op.BANG_EQUALS) {
				resultVal = !resultVal;
			}
			
			push(new Value(resultVal));
			break;
		case Op.ADD: case Op.SUB: case Op.MUL: case Op.DIV: case Op.POWER: case Op.MODULO: 
		case Op.SMALLER, Op.BIGGER, Op.SMALLER_EQUALS, Op.BIGGER_EQUALS:
			//for binary-operations execBinOp is called
			execBinOp(instr);
			break;	
		case Op.NEGATE:
			//pops to value, negates it, pushes it back on top
			val = pop();
			
			if(!val.isNumber()) {
				throw error("cannot negate a " + val.type);
			}
			double result = -val.asNumber();
			push(new Value(result));
			break;
		case Op.IN:
			//pops the current value, prints it, waits for an input and pushes it on the stack
			val = pop();
			System.out.print(val.dataToString());
			String inputTxt = consoleInput.nextLine();
			push(new Value(inputTxt));
			break;
		case Op.NIL:
			//pushes nil on the stack
			push(Value.nil());
			break;
		case Op.SET_GLOBAL:
			//reads the index of the global, pops the current value and stores it at the index in the globals array
			byte id = read();
			globals[id] = pop();
			break;
		case Op.GET_GLOBAL:
			//reads the index of the global, gets the current value from the globals array at the index and pushes it on the stack
			id = read();
			push(globals[id]);
			break;
		case Op.FALSE_JUMP:
			//pops the current value of the stack, jumps to the address if its false
			val = pop();
			short offset = readShort();
			if(val.isBool()) {
				if(!val.asBool()) {
					//jump by the offset
					ip += offset;
				}
			}else {
				throw error("expected a boolean, but found a " + val.type);
			}
			break;
		case Op.JUMP:
			//increases ip by a certain offset --> jumps forward in the code
			offset = readShort();
			ip += offset;
			break;
		case Op.JUMP_BACK:
			//decreases ip by a certain offset --> jumps backward in the code
			offset = readShort();
			ip -= offset;
			break;
		case Op.NUM_CAST:
			//casts the current value on the stack to a number if possible, otherwise outputs an error
			val = pop();
			if(val.isString()) {
				double castValue = Double.parseDouble(val.asString());
				push(new Value(castValue));
			}else if(val.isNumber()) {
				push(val);
			}else {
				throw error("cannot cast " + val.type + " to a number");
			}
			break;
		case Op.STRING_CAST:
			//casts the current value on the stack to a string if possible, otherwise outputs an error
			val = pop();
			push(new Value(val.dataToString()));
			break;
		case Op.BOOL_CAST:
			//casts the current value on the stack to a bool if possible, otherwise outputs an error
			val = pop();
			if(val.isString()) {
				boolean castValue = Boolean.parseBoolean(val.asString());
				push(new Value(castValue));
			}else if(val.isBool()) {
				push(val);
			}else {
				throw error("cannot cast " + val.type + " to a bool");
			}
			break;
		}
	}
	
	//reads the next 2 bytes (a short) from the code
	private short readShort() {
		byte a = read();
		byte b = read();
		
		return (short) ((a << 8) | b); 
	}
	
	//are these to values the same?
	private boolean valuesEqual(Value a, Value b) {
		if(a.type != b.type) {
			return false;
		}
		
		if(a.isNumber()) {
			return a.asNumber() == b.asNumber();
		}else if(a.isBool()) {
			return a.asBool() == b.asBool();
		}else if(a.isString()) {
			return a.asString().equals(b.asString());
		}
		
		return false;
	}
	
	private void execBinOp(byte instr) {
		//pops the top two values of the stack, performs the binary-operation and pushes the result back on the stack
		Value b = pop();
		Value a = pop();
		

		//determines which binary operation it is and between which types
		//e.g. is it an addition, is it between two strings or two integers?
		//if a binary operation cannot be carried out between the two types, an error is thrown with errorMsgForBinOp
		Value result = null;
		if(a.isNumber()) {
			double aVal = a.asNumber();
			
			if(b.isNumber()) {
				double bVal = b.asNumber();
				
				switch(instr) {
				case Op.ADD:
					double resultVal = aVal + bVal;
					result = new Value(resultVal);
					break;
				case Op.SUB:
					resultVal = aVal - bVal;
					result = new Value(resultVal);
					break;
				case Op.MUL:
					resultVal = aVal * bVal;
					result = new Value(resultVal);
					break;
				case Op.DIV:
					resultVal = aVal / bVal;
					result = new Value(resultVal);
					break;
				case Op.POWER:
					resultVal = Math.pow(aVal, bVal);
					result = new Value(resultVal);
					break;
				case Op.MODULO:
					resultVal = aVal % bVal;
					result = new Value(resultVal);
					break;
				case Op.SMALLER:
					result = new Value(aVal < bVal);
					break;
				case Op.BIGGER:
					result = new Value(aVal > bVal);
					break;
				case Op.SMALLER_EQUALS:
					result = new Value(aVal <= bVal);
					break;
				case Op.BIGGER_EQUALS:
					result = new Value(aVal >= bVal);
					break;
				}
				
				
			}else if(b.isString()) {
				switch(instr) {
				case Op.ADD:
					result = new Value(a.dataToString().concat(b.asString()));
					break;
				default:
					throw error(errorMsgForBinOp(instr, a, b));
				}
			}else {
				throw error(errorMsgForBinOp(instr, a, b));
			}
			
		}else if(a.isString()) {
			switch(instr) {
			case Op.ADD:
				result = new Value(a.asString().concat(b.dataToString()));
				break;
			default:
				throw error(errorMsgForBinOp(instr, a, b));
			}
		}else {
			throw error(errorMsgForBinOp(instr, a, b));
		}
		
		
		
		push(result);
	}
	
	//returns a specific error message for this binary-operator
	private String errorMsgForBinOp(byte instr, Value a, Value b) {
		switch(instr) {
		case Op.ADD:
			return "cannot add " + a.type + " and " + b.type;
		case Op.SUB:
			return "cannot subtract " + b.type + " from " + a.type; 
		case Op.MUL:
			return "cannot multiply " + a.type + " and " + b.type;
		case Op.DIV:
			return "cannot divide " + a.type + " by " + b.type;
		case Op.MODULO:
			return "cannot use the modulo operator on " + a.type + " and " + b.type;
		case Op.POWER:
			return "cannot raise a " + a.type + " to the power of a " + b.type;
		case Op.SMALLER, Op.SMALLER_EQUALS, Op.BIGGER, Op.BIGGER_EQUALS:
			return "cannot compare " + a.type + " and " + b.type;
		}
		
		return "unknown operator for " + a.type + " and " + b.type;
	}
	
	//prints out error-messages for the virtual machine
	private VMError error(String msg) {
		System.err.println(msg + " in line " + code.lines.get(ip));
		return new VMError();
	}
	
	//gets the byte of the code-data at the position i
	private byte getCode(int i) {
		return code.data.get(i);
	}
	
	//reads the index of a constant in the code (at ip + 1) and gets the constant from the constant-pool
	private Value readConstant() {
		byte index = read();
		Value val = code.constantPool.get(index);
		return val;
	}
	
	//reads the next byte
	private byte read() {
		ip += 1;
		return getCode(ip);
	}
}
